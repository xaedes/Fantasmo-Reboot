;Format: 
;[Vorschlag für Mnemonics - ] Befehlsbeschreibung [ : Parameter ]


NOP - Tue nichts
EXT - Erweiterter Befehl, tut bisher nichts

<Load Store Befehle> 9 Stück 
LDC - Lade Konstante in Register : 8 Bit Registernummer, 16 Bit Konstante
LD - Lies von MCU in Register : 8 Bit Registernummer, 16 Bit Adresse
ST - Schreib Register in MCU : 8 Bit Registernummer, 16 Bit Adresse
ILD - Lies von Adresse, die im (zweiten) Register steht, vom MCU in (erstes) Register : 8 Bit Registernummer, 8 Bit Registernummer
IST - Schreib (erstes) Register in Adresse welche im (zweiten) Register steht in MCU : 8 Bit Registernummer, 8 Bit Registernummer
IN - Liest 16 Bit Wert von Gerät welches im Parameter spezifiert wird in Register: 8 Bit Registernummer, 16 Bit Gerätenummer
OUT - Schreibt 16 Bit Wert von Register in Gerät welches im Parameter spezifiert wird: 8 Bit Registernummer, 16 Bit Gerätenummer
IIN - Liest 16 Bit Wert von Gerät welches durch Inhalt des (zweiten) Registers spezifiert wird in Register: 8 Bit Registernummer, 8 Bit Registernummer
IOUT - Schreibt 16 Bit Wert von Register in Gerät welches durch Inhalt des (zweiten) Registers spezifiert wird: 8 Bit Registernummer, 8 Bit Registernummer

<ALU Befehle> 9 Stück (mit 4 Bit codierbar)
//R1 = Register im ersten Parameter
//R2 = Register im zweiten Parameter
ADD - R1 <- R1 + R2 : 8 Bit Registernummer, 8 Bit Registernummer
SUB - R1 <- R1 - R2 : 8 Bit Registernummer, 8 Bit Registernummer
NOT - R1 <- NOT R1 : 8 Bit Registernummer
AND - R1 <- R1 AND R2 : 8 Bit Registernummer, 8 Bit Registernummer
OR  - R1 <- R1 OR R2 : 8 Bit Registernummer, 8 Bit Registernummer
XOR - R1 <- R1 XOR R2 : 8 Bit Registernummer, 8 Bit Registernummer
SHL - R1 <- R1 << R2 (Nullen werden eingeschoben) : 8 Bit Registernummer, 8 Bit Registernummer
SHR - R1 <- R1 >> R2 (Nullen werden eingeschoben) : 8 Bit Registernummer, 8 Bit Registernummer
CMP - R1 - R2 berechnen und Ergebnis verwerfen : 8 Bit Registernummer, 8 Bit Registernummer
LDF - R1 <- ALU Flags : 8 Bit Registernummer

<Jump Befehle> 3 Stück 
Flags = T(Always), C, Z
JMP - Schreibe Parameter in PC wenn C : 8 Bit Condition Codes, 16 Bit Adresse von nächsten Befehl
RJMP - Schreibe Parameter in PC wenn C : 8 Bit Condition Codes, 16 Bit Adresse von nächsten Befehl relativ zu Adresse: PC(von dieser OP) minus 2^15
IJMP - Schreibe Wert von Register in PC wenn C : 8 Bit Condition Codes, 8 Bit Registernummer

<Kontroll Befehle> 1 Stück
RESET


Jump, Load Store Befehle und NOP : 15 Stück (mit 5 Bit codierbar)

Der OP Code wird in einem Byte mit 8 Bit gespeichert. 
Da immer 16 Bit eingelesen werden sprechen wir dieses eingelesene Wort mit op an.
Gespeichert wird dieser Wert im Instruction Register 1 (IR1). 
Solte der Befehl weitere Operanden benötigen, die nicht in IR1 kodiert sind, wird das nächste eingelesene Wort in IR2 gespeichert.

Das höhererwertige Byte von op beinhaltet bereits Parameter für den Befehl, wenn es welche gibt.
Wenn es keine gibt, fängt der nächste Befehl an der Adresse an, die das höherwertige Byte von op beinhaltet hat.
op0 steht dafür, ob ein ALU Befehl(op0=1), oder einer der anderen kodiert ist. 
Der hintere Fall tritt ein, wenn op0 = 0.
Wenn es ein ALU Befehl ist, werden die vier nächsten Bit (op1-op4) an die ALU als Befehl weitergeleitet.
Ansonsten:
Die fünf Bit (op1-op5) kodieren nun den Befehl.

TODO : folgende Befehlsliste aktualisieren

Befehl	: Durch op2-op6 kodierte Binärzahl:
NOP		: 0
EXT		: 1
RESET	: 2
LDC		: 3
LD		: 4
ST		: 5
ILD		: 6
IST		: 7
IN		: 8
OUT		: 9
IIN		: 10
IOUT	: 11
JMP	    : 12
RJMP	: 13
IJMP	: 14


Komponenten:
In der Microcode Instruction Table steht für jeden OP Code die Microcode Instruction Startadresse
Condition Unit zum Testen der ALU Flags

Register im Steuerwerk (wenn nicht anders angegeben 16 Bit):
IR1  - Instruction Register 1
IR2  - Instruction Register 1
PC   - Programcounter
MIP  - Microcode Instruction Pointer
MA   - Memory Address Register
MD   - Memory Data Register
MS   - Memory Set Register
MITO - Microcode Instruction Table Opcode (8Bit)
MITV - Microcode Instruction Table Value
RN   - Register Nummer (8Bit)
RS   - Register Set - zum Setzen des Registers
R    - Register Value
DVN  - Device Nummer
DV   - Device Value
DVS  - Device Set
CC   - Condition Unit Code Set (8Bit)
C    - Condition Unit Result (1Bit)
ALUO - ALU Operation Set (4Bit)
ALU1 - ALU Parameter 1
ALU2 - ALU Parameter 2
ALU  - ALU Ergebnis

Befehlsablauf der für alle Befehle gleich ist:
MA <- PC
PC <- PC + 1
IR1 <- MD
MITO <- IR1[0..7]
MIP <- MITV



